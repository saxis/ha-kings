{"ast":null,"code":"import _asyncToGenerator from \"/Users/saxis/dev/angular_projects/ha-kings/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/**\n * @license Angular v20.3.0\n * (c) 2010-2025 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { inject, ErrorHandler, DestroyRef, RuntimeError, formatRuntimeError, assertNotInReactiveContext, assertInInjectionContext, Injector, ViewContext, ChangeDetectionScheduler, EffectScheduler, setInjectorProfilerContext, emitEffectCreatedEvent, EFFECTS, NodeInjectorDestroyRef, FLAGS, markAncestorsForTraversal, noop, setIsRefreshingViews, signalAsReadonlyFn, PendingTasks, signal } from './root_effect_scheduler.mjs';\nimport { setActiveConsumer, createComputed, SIGNAL, consumerDestroy, isInNotificationPhase } from './signal.mjs';\nimport { untracked as untracked$1, BASE_EFFECT_NODE, runEffect, createLinkedSignal, linkedSignalSetFn, linkedSignalUpdateFn } from './effect.mjs';\n\n/**\n * An `OutputEmitterRef` is created by the `output()` function and can be\n * used to emit values to consumers of your directive or component.\n *\n * Consumers of your directive/component can bind to the output and\n * subscribe to changes via the bound event syntax. For example:\n *\n * ```html\n * <my-comp (valueChange)=\"processNewValue($event)\" />\n * ```\n *\n * @publicAPI\n */\nclass OutputEmitterRef {\n  destroyed = false;\n  listeners = null;\n  errorHandler = inject(ErrorHandler, {\n    optional: true\n  });\n  /** @internal */\n  destroyRef = inject(DestroyRef);\n  constructor() {\n    // Clean-up all listeners and mark as destroyed upon destroy.\n    this.destroyRef.onDestroy(() => {\n      this.destroyed = true;\n      this.listeners = null;\n    });\n  }\n  subscribe(callback) {\n    if (this.destroyed) {\n      throw new RuntimeError(953 /* RuntimeErrorCode.OUTPUT_REF_DESTROYED */, ngDevMode && 'Unexpected subscription to destroyed `OutputRef`. ' + 'The owning directive/component is destroyed.');\n    }\n    (this.listeners ??= []).push(callback);\n    return {\n      unsubscribe: () => {\n        const idx = this.listeners?.indexOf(callback);\n        if (idx !== undefined && idx !== -1) {\n          this.listeners?.splice(idx, 1);\n        }\n      }\n    };\n  }\n  /** Emits a new value to the output. */\n  emit(value) {\n    if (this.destroyed) {\n      console.warn(formatRuntimeError(953 /* RuntimeErrorCode.OUTPUT_REF_DESTROYED */, ngDevMode && 'Unexpected emit for destroyed `OutputRef`. ' + 'The owning directive/component is destroyed.'));\n      return;\n    }\n    if (this.listeners === null) {\n      return;\n    }\n    const previousConsumer = setActiveConsumer(null);\n    try {\n      for (const listenerFn of this.listeners) {\n        try {\n          listenerFn(value);\n        } catch (err) {\n          this.errorHandler?.handleError(err);\n        }\n      }\n    } finally {\n      setActiveConsumer(previousConsumer);\n    }\n  }\n}\n/** Gets the owning `DestroyRef` for the given output. */\nfunction getOutputDestroyRef(ref) {\n  return ref.destroyRef;\n}\n\n/**\n * Execute an arbitrary function in a non-reactive (non-tracking) context. The executed function\n * can, optionally, return a value.\n */\nfunction untracked(nonReactiveReadsFn) {\n  return untracked$1(nonReactiveReadsFn);\n}\n\n/**\n * Create a computed `Signal` which derives a reactive value from an expression.\n */\nfunction computed(computation, options) {\n  const getter = createComputed(computation, options?.equal);\n  if (ngDevMode) {\n    getter.toString = () => `[Computed: ${getter()}]`;\n    getter[SIGNAL].debugName = options?.debugName;\n  }\n  return getter;\n}\nclass EffectRefImpl {\n  [SIGNAL];\n  constructor(node) {\n    this[SIGNAL] = node;\n  }\n  destroy() {\n    this[SIGNAL].destroy();\n  }\n}\n/**\n * Registers an \"effect\" that will be scheduled & executed whenever the signals that it reads\n * changes.\n *\n * Angular has two different kinds of effect: component effects and root effects. Component effects\n * are created when `effect()` is called from a component, directive, or within a service of a\n * component/directive. Root effects are created when `effect()` is called from outside the\n * component tree, such as in a root service.\n *\n * The two effect types differ in their timing. Component effects run as a component lifecycle\n * event during Angular's synchronization (change detection) process, and can safely read input\n * signals or create/destroy views that depend on component state. Root effects run as microtasks\n * and have no connection to the component tree or change detection.\n *\n * `effect()` must be run in injection context, unless the `injector` option is manually specified.\n *\n * @publicApi 20.0\n */\nfunction effect(effectFn, options) {\n  ngDevMode && assertNotInReactiveContext(effect, 'Call `effect` outside of a reactive context. For example, schedule the ' + 'effect inside the component constructor.');\n  if (ngDevMode && !options?.injector) {\n    assertInInjectionContext(effect);\n  }\n  if (ngDevMode && options?.allowSignalWrites !== undefined) {\n    console.warn(`The 'allowSignalWrites' flag is deprecated and no longer impacts effect() (writes are always allowed)`);\n  }\n  const injector = options?.injector ?? inject(Injector);\n  let destroyRef = options?.manualCleanup !== true ? injector.get(DestroyRef) : null;\n  let node;\n  const viewContext = injector.get(ViewContext, null, {\n    optional: true\n  });\n  const notifier = injector.get(ChangeDetectionScheduler);\n  if (viewContext !== null) {\n    // This effect was created in the context of a view, and will be associated with the view.\n    node = createViewEffect(viewContext.view, notifier, effectFn);\n    if (destroyRef instanceof NodeInjectorDestroyRef && destroyRef._lView === viewContext.view) {\n      // The effect is being created in the same view as the `DestroyRef` references, so it will be\n      // automatically destroyed without the need for an explicit `DestroyRef` registration.\n      destroyRef = null;\n    }\n  } else {\n    // This effect was created outside the context of a view, and will be scheduled independently.\n    node = createRootEffect(effectFn, injector.get(EffectScheduler), notifier);\n  }\n  node.injector = injector;\n  if (destroyRef !== null) {\n    // If we need to register for cleanup, do that here.\n    node.onDestroyFn = destroyRef.onDestroy(() => node.destroy());\n  }\n  const effectRef = new EffectRefImpl(node);\n  if (ngDevMode) {\n    node.debugName = options?.debugName ?? '';\n    const prevInjectorProfilerContext = setInjectorProfilerContext({\n      injector,\n      token: null\n    });\n    try {\n      emitEffectCreatedEvent(effectRef);\n    } finally {\n      setInjectorProfilerContext(prevInjectorProfilerContext);\n    }\n  }\n  return effectRef;\n}\nconst EFFECT_NODE = /* @__PURE__ */(() => ({\n  ...BASE_EFFECT_NODE,\n  cleanupFns: undefined,\n  zone: null,\n  onDestroyFn: noop,\n  run() {\n    if (ngDevMode && isInNotificationPhase()) {\n      throw new Error(`Schedulers cannot synchronously execute watches while scheduling.`);\n    }\n    // We clear `setIsRefreshingViews` so that `markForCheck()` within the body of an effect will\n    // cause CD to reach the component in question.\n    const prevRefreshingViews = setIsRefreshingViews(false);\n    try {\n      runEffect(this);\n    } finally {\n      setIsRefreshingViews(prevRefreshingViews);\n    }\n  },\n  cleanup() {\n    if (!this.cleanupFns?.length) {\n      return;\n    }\n    const prevConsumer = setActiveConsumer(null);\n    try {\n      // Attempt to run the cleanup functions. Regardless of failure or success, we consider\n      // cleanup \"completed\" and clear the list for the next run of the effect. Note that an error\n      // from the cleanup function will still crash the current run of the effect.\n      while (this.cleanupFns.length) {\n        this.cleanupFns.pop()();\n      }\n    } finally {\n      this.cleanupFns = [];\n      setActiveConsumer(prevConsumer);\n    }\n  }\n}))();\nconst ROOT_EFFECT_NODE = /* @__PURE__ */(() => ({\n  ...EFFECT_NODE,\n  consumerMarkedDirty() {\n    this.scheduler.schedule(this);\n    this.notifier.notify(12 /* NotificationSource.RootEffect */);\n  },\n  destroy() {\n    consumerDestroy(this);\n    this.onDestroyFn();\n    this.cleanup();\n    this.scheduler.remove(this);\n  }\n}))();\nconst VIEW_EFFECT_NODE = /* @__PURE__ */(() => ({\n  ...EFFECT_NODE,\n  consumerMarkedDirty() {\n    this.view[FLAGS] |= 8192 /* LViewFlags.HasChildViewsToRefresh */;\n    markAncestorsForTraversal(this.view);\n    this.notifier.notify(13 /* NotificationSource.ViewEffect */);\n  },\n  destroy() {\n    consumerDestroy(this);\n    this.onDestroyFn();\n    this.cleanup();\n    this.view[EFFECTS]?.delete(this);\n  }\n}))();\nfunction createViewEffect(view, notifier, fn) {\n  const node = Object.create(VIEW_EFFECT_NODE);\n  node.view = view;\n  node.zone = typeof Zone !== 'undefined' ? Zone.current : null;\n  node.notifier = notifier;\n  node.fn = createEffectFn(node, fn);\n  view[EFFECTS] ??= new Set();\n  view[EFFECTS].add(node);\n  node.consumerMarkedDirty(node);\n  return node;\n}\nfunction createRootEffect(fn, scheduler, notifier) {\n  const node = Object.create(ROOT_EFFECT_NODE);\n  node.fn = createEffectFn(node, fn);\n  node.scheduler = scheduler;\n  node.notifier = notifier;\n  node.zone = typeof Zone !== 'undefined' ? Zone.current : null;\n  node.scheduler.add(node);\n  node.notifier.notify(12 /* NotificationSource.RootEffect */);\n  return node;\n}\nfunction createEffectFn(node, fn) {\n  return () => {\n    fn(cleanupFn => (node.cleanupFns ??= []).push(cleanupFn));\n  };\n}\nconst identityFn = v => v;\nfunction linkedSignal(optionsOrComputation, options) {\n  if (typeof optionsOrComputation === 'function') {\n    const getter = createLinkedSignal(optionsOrComputation, identityFn, options?.equal);\n    return upgradeLinkedSignalGetter(getter);\n  } else {\n    const getter = createLinkedSignal(optionsOrComputation.source, optionsOrComputation.computation, optionsOrComputation.equal);\n    return upgradeLinkedSignalGetter(getter);\n  }\n}\nfunction upgradeLinkedSignalGetter(getter) {\n  if (ngDevMode) {\n    getter.toString = () => `[LinkedSignal: ${getter()}]`;\n  }\n  const node = getter[SIGNAL];\n  const upgradedGetter = getter;\n  upgradedGetter.set = newValue => linkedSignalSetFn(node, newValue);\n  upgradedGetter.update = updateFn => linkedSignalUpdateFn(node, updateFn);\n  upgradedGetter.asReadonly = signalAsReadonlyFn.bind(getter);\n  return upgradedGetter;\n}\n\n/**\n * Whether a `Resource.value()` should throw an error when the resource is in the error state.\n *\n * This internal flag is being used to gradually roll out this behavior.\n */\nlet RESOURCE_VALUE_THROWS_ERRORS_DEFAULT = true;\nfunction resource(options) {\n  if (ngDevMode && !options?.injector) {\n    assertInInjectionContext(resource);\n  }\n  const oldNameForParams = options.request;\n  const params = options.params ?? oldNameForParams ?? (() => null);\n  return new ResourceImpl(params, getLoader(options), options.defaultValue, options.equal ? wrapEqualityFn(options.equal) : undefined, options.injector ?? inject(Injector), RESOURCE_VALUE_THROWS_ERRORS_DEFAULT);\n}\n/**\n * Base class which implements `.value` as a `WritableSignal` by delegating `.set` and `.update`.\n */\nclass BaseWritableResource {\n  value;\n  constructor(value) {\n    this.value = value;\n    this.value.set = this.set.bind(this);\n    this.value.update = this.update.bind(this);\n    this.value.asReadonly = signalAsReadonlyFn;\n  }\n  isError = computed(() => this.status() === 'error');\n  update(updateFn) {\n    this.set(updateFn(untracked(this.value)));\n  }\n  isLoading = computed(() => this.status() === 'loading' || this.status() === 'reloading');\n  // Use a computed here to avoid triggering reactive consumers if the value changes while staying\n  // either defined or undefined.\n  isValueDefined = computed(() => {\n    // Check if it's in an error state first to prevent the error from bubbling up.\n    if (this.isError()) {\n      return false;\n    }\n    return this.value() !== undefined;\n  });\n  hasValue() {\n    return this.isValueDefined();\n  }\n  asReadonly() {\n    return this;\n  }\n}\n/**\n * Implementation for `resource()` which uses a `linkedSignal` to manage the resource's state.\n */\nclass ResourceImpl extends BaseWritableResource {\n  loaderFn;\n  equal;\n  pendingTasks;\n  /**\n   * The current state of the resource. Status, value, and error are derived from this.\n   */\n  state;\n  /**\n   * Combines the current request with a reload counter which allows the resource to be reloaded on\n   * imperative command.\n   */\n  extRequest;\n  effectRef;\n  pendingController;\n  resolvePendingTask = undefined;\n  destroyed = false;\n  unregisterOnDestroy;\n  constructor(request, loaderFn, defaultValue, equal, injector, throwErrorsFromValue = RESOURCE_VALUE_THROWS_ERRORS_DEFAULT) {\n    super(\n    // Feed a computed signal for the value to `BaseWritableResource`, which will upgrade it to a\n    // `WritableSignal` that delegates to `ResourceImpl.set`.\n    computed(() => {\n      const streamValue = this.state().stream?.();\n      if (!streamValue) {\n        return defaultValue;\n      }\n      // Prevents `hasValue()` from throwing an error when a reload happened in the error state\n      if (this.state().status === 'loading' && this.error()) {\n        return defaultValue;\n      }\n      if (!isResolved(streamValue)) {\n        if (throwErrorsFromValue) {\n          throw new ResourceValueError(this.error());\n        } else {\n          return defaultValue;\n        }\n      }\n      return streamValue.value;\n    }, {\n      equal\n    }));\n    this.loaderFn = loaderFn;\n    this.equal = equal;\n    // Extend `request()` to include a writable reload signal.\n    this.extRequest = linkedSignal({\n      source: request,\n      computation: request => ({\n        request,\n        reload: 0\n      })\n    });\n    // The main resource state is managed in a `linkedSignal`, which allows the resource to change\n    // state instantaneously when the request signal changes.\n    this.state = linkedSignal({\n      // Whenever the request changes,\n      source: this.extRequest,\n      // Compute the state of the resource given a change in status.\n      computation: (extRequest, previous) => {\n        const status = extRequest.request === undefined ? 'idle' : 'loading';\n        if (!previous) {\n          return {\n            extRequest,\n            status,\n            previousStatus: 'idle',\n            stream: undefined\n          };\n        } else {\n          return {\n            extRequest,\n            status,\n            previousStatus: projectStatusOfState(previous.value),\n            // If the request hasn't changed, keep the previous stream.\n            stream: previous.value.extRequest.request === extRequest.request ? previous.value.stream : undefined\n          };\n        }\n      }\n    });\n    this.effectRef = effect(this.loadEffect.bind(this), {\n      injector,\n      manualCleanup: true\n    });\n    this.pendingTasks = injector.get(PendingTasks);\n    // Cancel any pending request when the resource itself is destroyed.\n    this.unregisterOnDestroy = injector.get(DestroyRef).onDestroy(() => this.destroy());\n  }\n  status = computed(() => projectStatusOfState(this.state()));\n  error = computed(() => {\n    const stream = this.state().stream?.();\n    return stream && !isResolved(stream) ? stream.error : undefined;\n  });\n  /**\n   * Called either directly via `WritableResource.set` or via `.value.set()`.\n   */\n  set(value) {\n    if (this.destroyed) {\n      return;\n    }\n    const error = untracked(this.error);\n    const state = untracked(this.state);\n    if (!error) {\n      const current = untracked(this.value);\n      if (state.status === 'local' && (this.equal ? this.equal(current, value) : current === value)) {\n        return;\n      }\n    }\n    // Enter Local state with the user-defined value.\n    this.state.set({\n      extRequest: state.extRequest,\n      status: 'local',\n      previousStatus: 'local',\n      stream: signal({\n        value\n      })\n    });\n    // We're departing from whatever state the resource was in previously, so cancel any in-progress\n    // loading operations.\n    this.abortInProgressLoad();\n  }\n  reload() {\n    // We don't want to restart in-progress loads.\n    const {\n      status\n    } = untracked(this.state);\n    if (status === 'idle' || status === 'loading') {\n      return false;\n    }\n    // Increment the request reload to trigger the `state` linked signal to switch us to `Reload`\n    this.extRequest.update(({\n      request,\n      reload\n    }) => ({\n      request,\n      reload: reload + 1\n    }));\n    return true;\n  }\n  destroy() {\n    this.destroyed = true;\n    this.unregisterOnDestroy();\n    this.effectRef.destroy();\n    this.abortInProgressLoad();\n    // Destroyed resources enter Idle state.\n    this.state.set({\n      extRequest: {\n        request: undefined,\n        reload: 0\n      },\n      status: 'idle',\n      previousStatus: 'idle',\n      stream: undefined\n    });\n  }\n  loadEffect() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const extRequest = _this.extRequest();\n      // Capture the previous status before any state transitions. Note that this is `untracked` since\n      // we do not want the effect to depend on the state of the resource, only on the request.\n      const {\n        status: currentStatus,\n        previousStatus\n      } = untracked(_this.state);\n      if (extRequest.request === undefined) {\n        // Nothing to load (and we should already be in a non-loading state).\n        return;\n      } else if (currentStatus !== 'loading') {\n        // We're not in a loading or reloading state, so this loading request is stale.\n        return;\n      }\n      // Cancel any previous loading attempts.\n      _this.abortInProgressLoad();\n      // Capturing _this_ load's pending task in a local variable is important here. We may attempt to\n      // resolve it twice:\n      //\n      //  1. when the loading function promise resolves/rejects\n      //  2. when cancelling the loading operation\n      //\n      // After the loading operation is cancelled, `this.resolvePendingTask` no longer represents this\n      // particular task, but this `await` may eventually resolve/reject. Thus, when we cancel in\n      // response to (1) below, we need to cancel the locally saved task.\n      let resolvePendingTask = _this.resolvePendingTask = _this.pendingTasks.add();\n      const {\n        signal: abortSignal\n      } = _this.pendingController = new AbortController();\n      try {\n        // The actual loading is run through `untracked` - only the request side of `resource` is\n        // reactive. This avoids any confusion with signals tracking or not tracking depending on\n        // which side of the `await` they are.\n        const stream = yield untracked(() => {\n          return _this.loaderFn({\n            params: extRequest.request,\n            // TODO(alxhub): cleanup after g3 removal of `request` alias.\n            request: extRequest.request,\n            abortSignal,\n            previous: {\n              status: previousStatus\n            }\n          });\n        });\n        // If this request has been aborted, or the current request no longer\n        // matches this load, then we should ignore this resolution.\n        if (abortSignal.aborted || untracked(_this.extRequest) !== extRequest) {\n          return;\n        }\n        _this.state.set({\n          extRequest,\n          status: 'resolved',\n          previousStatus: 'resolved',\n          stream\n        });\n      } catch (err) {\n        if (abortSignal.aborted || untracked(_this.extRequest) !== extRequest) {\n          return;\n        }\n        _this.state.set({\n          extRequest,\n          status: 'resolved',\n          previousStatus: 'error',\n          stream: signal({\n            error: encapsulateResourceError(err)\n          })\n        });\n      } finally {\n        // Resolve the pending task now that the resource has a value.\n        resolvePendingTask?.();\n        resolvePendingTask = undefined;\n      }\n    })();\n  }\n  abortInProgressLoad() {\n    untracked(() => this.pendingController?.abort());\n    this.pendingController = undefined;\n    // Once the load is aborted, we no longer want to block stability on its resolution.\n    this.resolvePendingTask?.();\n    this.resolvePendingTask = undefined;\n  }\n}\n/**\n * Wraps an equality function to handle either value being `undefined`.\n */\nfunction wrapEqualityFn(equal) {\n  return (a, b) => a === undefined || b === undefined ? a === b : equal(a, b);\n}\nfunction getLoader(options) {\n  if (isStreamingResourceOptions(options)) {\n    return options.stream;\n  }\n  return /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* (params) {\n      try {\n        return signal({\n          value: yield options.loader(params)\n        });\n      } catch (err) {\n        return signal({\n          error: encapsulateResourceError(err)\n        });\n      }\n    });\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n}\nfunction isStreamingResourceOptions(options) {\n  return !!options.stream;\n}\n/**\n * Project from a state with `ResourceInternalStatus` to the user-facing `ResourceStatus`\n */\nfunction projectStatusOfState(state) {\n  switch (state.status) {\n    case 'loading':\n      return state.extRequest.reload === 0 ? 'loading' : 'reloading';\n    case 'resolved':\n      return isResolved(state.stream()) ? 'resolved' : 'error';\n    default:\n      return state.status;\n  }\n}\nfunction isResolved(state) {\n  return state.error === undefined;\n}\nfunction encapsulateResourceError(error) {\n  if (error instanceof Error) {\n    return error;\n  }\n  return new ResourceWrappedError(error);\n}\nclass ResourceValueError extends Error {\n  constructor(error) {\n    super(ngDevMode ? `Resource is currently in an error state (see Error.cause for details): ${error.message}` : error.message, {\n      cause: error\n    });\n  }\n}\nclass ResourceWrappedError extends Error {\n  constructor(error) {\n    super(ngDevMode ? `Resource returned an error that's not an Error instance: ${String(error)}. Check this error's .cause for the actual error.` : String(error), {\n      cause: error\n    });\n  }\n}\nexport { OutputEmitterRef, ResourceImpl, computed, effect, encapsulateResourceError, getOutputDestroyRef, linkedSignal, resource, untracked };","map":{"version":3,"names":["inject","ErrorHandler","DestroyRef","RuntimeError","formatRuntimeError","assertNotInReactiveContext","assertInInjectionContext","Injector","ViewContext","ChangeDetectionScheduler","EffectScheduler","setInjectorProfilerContext","emitEffectCreatedEvent","EFFECTS","NodeInjectorDestroyRef","FLAGS","markAncestorsForTraversal","noop","setIsRefreshingViews","signalAsReadonlyFn","PendingTasks","signal","setActiveConsumer","createComputed","SIGNAL","consumerDestroy","isInNotificationPhase","untracked","untracked$1","BASE_EFFECT_NODE","runEffect","createLinkedSignal","linkedSignalSetFn","linkedSignalUpdateFn","OutputEmitterRef","destroyed","listeners","errorHandler","optional","destroyRef","constructor","onDestroy","subscribe","callback","ngDevMode","push","unsubscribe","idx","indexOf","undefined","splice","emit","value","console","warn","previousConsumer","listenerFn","err","handleError","getOutputDestroyRef","ref","nonReactiveReadsFn","computed","computation","options","getter","equal","toString","debugName","EffectRefImpl","node","destroy","effect","effectFn","injector","allowSignalWrites","manualCleanup","get","viewContext","notifier","createViewEffect","view","_lView","createRootEffect","onDestroyFn","effectRef","prevInjectorProfilerContext","token","EFFECT_NODE","cleanupFns","zone","run","Error","prevRefreshingViews","cleanup","length","prevConsumer","pop","ROOT_EFFECT_NODE","consumerMarkedDirty","scheduler","schedule","notify","remove","VIEW_EFFECT_NODE","delete","fn","Object","create","Zone","current","createEffectFn","Set","add","cleanupFn","identityFn","v","linkedSignal","optionsOrComputation","upgradeLinkedSignalGetter","source","upgradedGetter","set","newValue","update","updateFn","asReadonly","bind","RESOURCE_VALUE_THROWS_ERRORS_DEFAULT","resource","oldNameForParams","request","params","ResourceImpl","getLoader","defaultValue","wrapEqualityFn","BaseWritableResource","isError","status","isLoading","isValueDefined","hasValue","loaderFn","pendingTasks","state","extRequest","pendingController","resolvePendingTask","unregisterOnDestroy","throwErrorsFromValue","streamValue","stream","error","isResolved","ResourceValueError","reload","previous","previousStatus","projectStatusOfState","loadEffect","abortInProgressLoad","_this","_asyncToGenerator","currentStatus","abortSignal","AbortController","aborted","encapsulateResourceError","abort","a","b","isStreamingResourceOptions","_ref","loader","_x","apply","arguments","ResourceWrappedError","message","cause","String"],"sources":["/Users/saxis/dev/angular_projects/ha-kings/node_modules/@angular/core/fesm2022/resource.mjs"],"sourcesContent":["/**\n * @license Angular v20.3.0\n * (c) 2010-2025 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { inject, ErrorHandler, DestroyRef, RuntimeError, formatRuntimeError, assertNotInReactiveContext, assertInInjectionContext, Injector, ViewContext, ChangeDetectionScheduler, EffectScheduler, setInjectorProfilerContext, emitEffectCreatedEvent, EFFECTS, NodeInjectorDestroyRef, FLAGS, markAncestorsForTraversal, noop, setIsRefreshingViews, signalAsReadonlyFn, PendingTasks, signal } from './root_effect_scheduler.mjs';\nimport { setActiveConsumer, createComputed, SIGNAL, consumerDestroy, isInNotificationPhase } from './signal.mjs';\nimport { untracked as untracked$1, BASE_EFFECT_NODE, runEffect, createLinkedSignal, linkedSignalSetFn, linkedSignalUpdateFn } from './effect.mjs';\n\n/**\n * An `OutputEmitterRef` is created by the `output()` function and can be\n * used to emit values to consumers of your directive or component.\n *\n * Consumers of your directive/component can bind to the output and\n * subscribe to changes via the bound event syntax. For example:\n *\n * ```html\n * <my-comp (valueChange)=\"processNewValue($event)\" />\n * ```\n *\n * @publicAPI\n */\nclass OutputEmitterRef {\n    destroyed = false;\n    listeners = null;\n    errorHandler = inject(ErrorHandler, { optional: true });\n    /** @internal */\n    destroyRef = inject(DestroyRef);\n    constructor() {\n        // Clean-up all listeners and mark as destroyed upon destroy.\n        this.destroyRef.onDestroy(() => {\n            this.destroyed = true;\n            this.listeners = null;\n        });\n    }\n    subscribe(callback) {\n        if (this.destroyed) {\n            throw new RuntimeError(953 /* RuntimeErrorCode.OUTPUT_REF_DESTROYED */, ngDevMode &&\n                'Unexpected subscription to destroyed `OutputRef`. ' +\n                    'The owning directive/component is destroyed.');\n        }\n        (this.listeners ??= []).push(callback);\n        return {\n            unsubscribe: () => {\n                const idx = this.listeners?.indexOf(callback);\n                if (idx !== undefined && idx !== -1) {\n                    this.listeners?.splice(idx, 1);\n                }\n            },\n        };\n    }\n    /** Emits a new value to the output. */\n    emit(value) {\n        if (this.destroyed) {\n            console.warn(formatRuntimeError(953 /* RuntimeErrorCode.OUTPUT_REF_DESTROYED */, ngDevMode &&\n                'Unexpected emit for destroyed `OutputRef`. ' +\n                    'The owning directive/component is destroyed.'));\n            return;\n        }\n        if (this.listeners === null) {\n            return;\n        }\n        const previousConsumer = setActiveConsumer(null);\n        try {\n            for (const listenerFn of this.listeners) {\n                try {\n                    listenerFn(value);\n                }\n                catch (err) {\n                    this.errorHandler?.handleError(err);\n                }\n            }\n        }\n        finally {\n            setActiveConsumer(previousConsumer);\n        }\n    }\n}\n/** Gets the owning `DestroyRef` for the given output. */\nfunction getOutputDestroyRef(ref) {\n    return ref.destroyRef;\n}\n\n/**\n * Execute an arbitrary function in a non-reactive (non-tracking) context. The executed function\n * can, optionally, return a value.\n */\nfunction untracked(nonReactiveReadsFn) {\n    return untracked$1(nonReactiveReadsFn);\n}\n\n/**\n * Create a computed `Signal` which derives a reactive value from an expression.\n */\nfunction computed(computation, options) {\n    const getter = createComputed(computation, options?.equal);\n    if (ngDevMode) {\n        getter.toString = () => `[Computed: ${getter()}]`;\n        getter[SIGNAL].debugName = options?.debugName;\n    }\n    return getter;\n}\n\nclass EffectRefImpl {\n    [SIGNAL];\n    constructor(node) {\n        this[SIGNAL] = node;\n    }\n    destroy() {\n        this[SIGNAL].destroy();\n    }\n}\n/**\n * Registers an \"effect\" that will be scheduled & executed whenever the signals that it reads\n * changes.\n *\n * Angular has two different kinds of effect: component effects and root effects. Component effects\n * are created when `effect()` is called from a component, directive, or within a service of a\n * component/directive. Root effects are created when `effect()` is called from outside the\n * component tree, such as in a root service.\n *\n * The two effect types differ in their timing. Component effects run as a component lifecycle\n * event during Angular's synchronization (change detection) process, and can safely read input\n * signals or create/destroy views that depend on component state. Root effects run as microtasks\n * and have no connection to the component tree or change detection.\n *\n * `effect()` must be run in injection context, unless the `injector` option is manually specified.\n *\n * @publicApi 20.0\n */\nfunction effect(effectFn, options) {\n    ngDevMode &&\n        assertNotInReactiveContext(effect, 'Call `effect` outside of a reactive context. For example, schedule the ' +\n            'effect inside the component constructor.');\n    if (ngDevMode && !options?.injector) {\n        assertInInjectionContext(effect);\n    }\n    if (ngDevMode && options?.allowSignalWrites !== undefined) {\n        console.warn(`The 'allowSignalWrites' flag is deprecated and no longer impacts effect() (writes are always allowed)`);\n    }\n    const injector = options?.injector ?? inject(Injector);\n    let destroyRef = options?.manualCleanup !== true ? injector.get(DestroyRef) : null;\n    let node;\n    const viewContext = injector.get(ViewContext, null, { optional: true });\n    const notifier = injector.get(ChangeDetectionScheduler);\n    if (viewContext !== null) {\n        // This effect was created in the context of a view, and will be associated with the view.\n        node = createViewEffect(viewContext.view, notifier, effectFn);\n        if (destroyRef instanceof NodeInjectorDestroyRef && destroyRef._lView === viewContext.view) {\n            // The effect is being created in the same view as the `DestroyRef` references, so it will be\n            // automatically destroyed without the need for an explicit `DestroyRef` registration.\n            destroyRef = null;\n        }\n    }\n    else {\n        // This effect was created outside the context of a view, and will be scheduled independently.\n        node = createRootEffect(effectFn, injector.get(EffectScheduler), notifier);\n    }\n    node.injector = injector;\n    if (destroyRef !== null) {\n        // If we need to register for cleanup, do that here.\n        node.onDestroyFn = destroyRef.onDestroy(() => node.destroy());\n    }\n    const effectRef = new EffectRefImpl(node);\n    if (ngDevMode) {\n        node.debugName = options?.debugName ?? '';\n        const prevInjectorProfilerContext = setInjectorProfilerContext({ injector, token: null });\n        try {\n            emitEffectCreatedEvent(effectRef);\n        }\n        finally {\n            setInjectorProfilerContext(prevInjectorProfilerContext);\n        }\n    }\n    return effectRef;\n}\nconst EFFECT_NODE = \n/* @__PURE__ */ (() => ({\n    ...BASE_EFFECT_NODE,\n    cleanupFns: undefined,\n    zone: null,\n    onDestroyFn: noop,\n    run() {\n        if (ngDevMode && isInNotificationPhase()) {\n            throw new Error(`Schedulers cannot synchronously execute watches while scheduling.`);\n        }\n        // We clear `setIsRefreshingViews` so that `markForCheck()` within the body of an effect will\n        // cause CD to reach the component in question.\n        const prevRefreshingViews = setIsRefreshingViews(false);\n        try {\n            runEffect(this);\n        }\n        finally {\n            setIsRefreshingViews(prevRefreshingViews);\n        }\n    },\n    cleanup() {\n        if (!this.cleanupFns?.length) {\n            return;\n        }\n        const prevConsumer = setActiveConsumer(null);\n        try {\n            // Attempt to run the cleanup functions. Regardless of failure or success, we consider\n            // cleanup \"completed\" and clear the list for the next run of the effect. Note that an error\n            // from the cleanup function will still crash the current run of the effect.\n            while (this.cleanupFns.length) {\n                this.cleanupFns.pop()();\n            }\n        }\n        finally {\n            this.cleanupFns = [];\n            setActiveConsumer(prevConsumer);\n        }\n    },\n}))();\nconst ROOT_EFFECT_NODE = \n/* @__PURE__ */ (() => ({\n    ...EFFECT_NODE,\n    consumerMarkedDirty() {\n        this.scheduler.schedule(this);\n        this.notifier.notify(12 /* NotificationSource.RootEffect */);\n    },\n    destroy() {\n        consumerDestroy(this);\n        this.onDestroyFn();\n        this.cleanup();\n        this.scheduler.remove(this);\n    },\n}))();\nconst VIEW_EFFECT_NODE = \n/* @__PURE__ */ (() => ({\n    ...EFFECT_NODE,\n    consumerMarkedDirty() {\n        this.view[FLAGS] |= 8192 /* LViewFlags.HasChildViewsToRefresh */;\n        markAncestorsForTraversal(this.view);\n        this.notifier.notify(13 /* NotificationSource.ViewEffect */);\n    },\n    destroy() {\n        consumerDestroy(this);\n        this.onDestroyFn();\n        this.cleanup();\n        this.view[EFFECTS]?.delete(this);\n    },\n}))();\nfunction createViewEffect(view, notifier, fn) {\n    const node = Object.create(VIEW_EFFECT_NODE);\n    node.view = view;\n    node.zone = typeof Zone !== 'undefined' ? Zone.current : null;\n    node.notifier = notifier;\n    node.fn = createEffectFn(node, fn);\n    view[EFFECTS] ??= new Set();\n    view[EFFECTS].add(node);\n    node.consumerMarkedDirty(node);\n    return node;\n}\nfunction createRootEffect(fn, scheduler, notifier) {\n    const node = Object.create(ROOT_EFFECT_NODE);\n    node.fn = createEffectFn(node, fn);\n    node.scheduler = scheduler;\n    node.notifier = notifier;\n    node.zone = typeof Zone !== 'undefined' ? Zone.current : null;\n    node.scheduler.add(node);\n    node.notifier.notify(12 /* NotificationSource.RootEffect */);\n    return node;\n}\nfunction createEffectFn(node, fn) {\n    return () => {\n        fn((cleanupFn) => (node.cleanupFns ??= []).push(cleanupFn));\n    };\n}\n\nconst identityFn = (v) => v;\nfunction linkedSignal(optionsOrComputation, options) {\n    if (typeof optionsOrComputation === 'function') {\n        const getter = createLinkedSignal(optionsOrComputation, (identityFn), options?.equal);\n        return upgradeLinkedSignalGetter(getter);\n    }\n    else {\n        const getter = createLinkedSignal(optionsOrComputation.source, optionsOrComputation.computation, optionsOrComputation.equal);\n        return upgradeLinkedSignalGetter(getter);\n    }\n}\nfunction upgradeLinkedSignalGetter(getter) {\n    if (ngDevMode) {\n        getter.toString = () => `[LinkedSignal: ${getter()}]`;\n    }\n    const node = getter[SIGNAL];\n    const upgradedGetter = getter;\n    upgradedGetter.set = (newValue) => linkedSignalSetFn(node, newValue);\n    upgradedGetter.update = (updateFn) => linkedSignalUpdateFn(node, updateFn);\n    upgradedGetter.asReadonly = signalAsReadonlyFn.bind(getter);\n    return upgradedGetter;\n}\n\n/**\n * Whether a `Resource.value()` should throw an error when the resource is in the error state.\n *\n * This internal flag is being used to gradually roll out this behavior.\n */\nlet RESOURCE_VALUE_THROWS_ERRORS_DEFAULT = true;\nfunction resource(options) {\n    if (ngDevMode && !options?.injector) {\n        assertInInjectionContext(resource);\n    }\n    const oldNameForParams = options.request;\n    const params = (options.params ?? oldNameForParams ?? (() => null));\n    return new ResourceImpl(params, getLoader(options), options.defaultValue, options.equal ? wrapEqualityFn(options.equal) : undefined, options.injector ?? inject(Injector), RESOURCE_VALUE_THROWS_ERRORS_DEFAULT);\n}\n/**\n * Base class which implements `.value` as a `WritableSignal` by delegating `.set` and `.update`.\n */\nclass BaseWritableResource {\n    value;\n    constructor(value) {\n        this.value = value;\n        this.value.set = this.set.bind(this);\n        this.value.update = this.update.bind(this);\n        this.value.asReadonly = signalAsReadonlyFn;\n    }\n    isError = computed(() => this.status() === 'error');\n    update(updateFn) {\n        this.set(updateFn(untracked(this.value)));\n    }\n    isLoading = computed(() => this.status() === 'loading' || this.status() === 'reloading');\n    // Use a computed here to avoid triggering reactive consumers if the value changes while staying\n    // either defined or undefined.\n    isValueDefined = computed(() => {\n        // Check if it's in an error state first to prevent the error from bubbling up.\n        if (this.isError()) {\n            return false;\n        }\n        return this.value() !== undefined;\n    });\n    hasValue() {\n        return this.isValueDefined();\n    }\n    asReadonly() {\n        return this;\n    }\n}\n/**\n * Implementation for `resource()` which uses a `linkedSignal` to manage the resource's state.\n */\nclass ResourceImpl extends BaseWritableResource {\n    loaderFn;\n    equal;\n    pendingTasks;\n    /**\n     * The current state of the resource. Status, value, and error are derived from this.\n     */\n    state;\n    /**\n     * Combines the current request with a reload counter which allows the resource to be reloaded on\n     * imperative command.\n     */\n    extRequest;\n    effectRef;\n    pendingController;\n    resolvePendingTask = undefined;\n    destroyed = false;\n    unregisterOnDestroy;\n    constructor(request, loaderFn, defaultValue, equal, injector, throwErrorsFromValue = RESOURCE_VALUE_THROWS_ERRORS_DEFAULT) {\n        super(\n        // Feed a computed signal for the value to `BaseWritableResource`, which will upgrade it to a\n        // `WritableSignal` that delegates to `ResourceImpl.set`.\n        computed(() => {\n            const streamValue = this.state().stream?.();\n            if (!streamValue) {\n                return defaultValue;\n            }\n            // Prevents `hasValue()` from throwing an error when a reload happened in the error state\n            if (this.state().status === 'loading' && this.error()) {\n                return defaultValue;\n            }\n            if (!isResolved(streamValue)) {\n                if (throwErrorsFromValue) {\n                    throw new ResourceValueError(this.error());\n                }\n                else {\n                    return defaultValue;\n                }\n            }\n            return streamValue.value;\n        }, { equal }));\n        this.loaderFn = loaderFn;\n        this.equal = equal;\n        // Extend `request()` to include a writable reload signal.\n        this.extRequest = linkedSignal({\n            source: request,\n            computation: (request) => ({ request, reload: 0 }),\n        });\n        // The main resource state is managed in a `linkedSignal`, which allows the resource to change\n        // state instantaneously when the request signal changes.\n        this.state = linkedSignal({\n            // Whenever the request changes,\n            source: this.extRequest,\n            // Compute the state of the resource given a change in status.\n            computation: (extRequest, previous) => {\n                const status = extRequest.request === undefined ? 'idle' : 'loading';\n                if (!previous) {\n                    return {\n                        extRequest,\n                        status,\n                        previousStatus: 'idle',\n                        stream: undefined,\n                    };\n                }\n                else {\n                    return {\n                        extRequest,\n                        status,\n                        previousStatus: projectStatusOfState(previous.value),\n                        // If the request hasn't changed, keep the previous stream.\n                        stream: previous.value.extRequest.request === extRequest.request\n                            ? previous.value.stream\n                            : undefined,\n                    };\n                }\n            },\n        });\n        this.effectRef = effect(this.loadEffect.bind(this), {\n            injector,\n            manualCleanup: true,\n        });\n        this.pendingTasks = injector.get(PendingTasks);\n        // Cancel any pending request when the resource itself is destroyed.\n        this.unregisterOnDestroy = injector.get(DestroyRef).onDestroy(() => this.destroy());\n    }\n    status = computed(() => projectStatusOfState(this.state()));\n    error = computed(() => {\n        const stream = this.state().stream?.();\n        return stream && !isResolved(stream) ? stream.error : undefined;\n    });\n    /**\n     * Called either directly via `WritableResource.set` or via `.value.set()`.\n     */\n    set(value) {\n        if (this.destroyed) {\n            return;\n        }\n        const error = untracked(this.error);\n        const state = untracked(this.state);\n        if (!error) {\n            const current = untracked(this.value);\n            if (state.status === 'local' &&\n                (this.equal ? this.equal(current, value) : current === value)) {\n                return;\n            }\n        }\n        // Enter Local state with the user-defined value.\n        this.state.set({\n            extRequest: state.extRequest,\n            status: 'local',\n            previousStatus: 'local',\n            stream: signal({ value }),\n        });\n        // We're departing from whatever state the resource was in previously, so cancel any in-progress\n        // loading operations.\n        this.abortInProgressLoad();\n    }\n    reload() {\n        // We don't want to restart in-progress loads.\n        const { status } = untracked(this.state);\n        if (status === 'idle' || status === 'loading') {\n            return false;\n        }\n        // Increment the request reload to trigger the `state` linked signal to switch us to `Reload`\n        this.extRequest.update(({ request, reload }) => ({ request, reload: reload + 1 }));\n        return true;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.unregisterOnDestroy();\n        this.effectRef.destroy();\n        this.abortInProgressLoad();\n        // Destroyed resources enter Idle state.\n        this.state.set({\n            extRequest: { request: undefined, reload: 0 },\n            status: 'idle',\n            previousStatus: 'idle',\n            stream: undefined,\n        });\n    }\n    async loadEffect() {\n        const extRequest = this.extRequest();\n        // Capture the previous status before any state transitions. Note that this is `untracked` since\n        // we do not want the effect to depend on the state of the resource, only on the request.\n        const { status: currentStatus, previousStatus } = untracked(this.state);\n        if (extRequest.request === undefined) {\n            // Nothing to load (and we should already be in a non-loading state).\n            return;\n        }\n        else if (currentStatus !== 'loading') {\n            // We're not in a loading or reloading state, so this loading request is stale.\n            return;\n        }\n        // Cancel any previous loading attempts.\n        this.abortInProgressLoad();\n        // Capturing _this_ load's pending task in a local variable is important here. We may attempt to\n        // resolve it twice:\n        //\n        //  1. when the loading function promise resolves/rejects\n        //  2. when cancelling the loading operation\n        //\n        // After the loading operation is cancelled, `this.resolvePendingTask` no longer represents this\n        // particular task, but this `await` may eventually resolve/reject. Thus, when we cancel in\n        // response to (1) below, we need to cancel the locally saved task.\n        let resolvePendingTask = (this.resolvePendingTask =\n            this.pendingTasks.add());\n        const { signal: abortSignal } = (this.pendingController = new AbortController());\n        try {\n            // The actual loading is run through `untracked` - only the request side of `resource` is\n            // reactive. This avoids any confusion with signals tracking or not tracking depending on\n            // which side of the `await` they are.\n            const stream = await untracked(() => {\n                return this.loaderFn({\n                    params: extRequest.request,\n                    // TODO(alxhub): cleanup after g3 removal of `request` alias.\n                    request: extRequest.request,\n                    abortSignal,\n                    previous: {\n                        status: previousStatus,\n                    },\n                });\n            });\n            // If this request has been aborted, or the current request no longer\n            // matches this load, then we should ignore this resolution.\n            if (abortSignal.aborted || untracked(this.extRequest) !== extRequest) {\n                return;\n            }\n            this.state.set({\n                extRequest,\n                status: 'resolved',\n                previousStatus: 'resolved',\n                stream,\n            });\n        }\n        catch (err) {\n            if (abortSignal.aborted || untracked(this.extRequest) !== extRequest) {\n                return;\n            }\n            this.state.set({\n                extRequest,\n                status: 'resolved',\n                previousStatus: 'error',\n                stream: signal({ error: encapsulateResourceError(err) }),\n            });\n        }\n        finally {\n            // Resolve the pending task now that the resource has a value.\n            resolvePendingTask?.();\n            resolvePendingTask = undefined;\n        }\n    }\n    abortInProgressLoad() {\n        untracked(() => this.pendingController?.abort());\n        this.pendingController = undefined;\n        // Once the load is aborted, we no longer want to block stability on its resolution.\n        this.resolvePendingTask?.();\n        this.resolvePendingTask = undefined;\n    }\n}\n/**\n * Wraps an equality function to handle either value being `undefined`.\n */\nfunction wrapEqualityFn(equal) {\n    return (a, b) => (a === undefined || b === undefined ? a === b : equal(a, b));\n}\nfunction getLoader(options) {\n    if (isStreamingResourceOptions(options)) {\n        return options.stream;\n    }\n    return async (params) => {\n        try {\n            return signal({ value: await options.loader(params) });\n        }\n        catch (err) {\n            return signal({ error: encapsulateResourceError(err) });\n        }\n    };\n}\nfunction isStreamingResourceOptions(options) {\n    return !!options.stream;\n}\n/**\n * Project from a state with `ResourceInternalStatus` to the user-facing `ResourceStatus`\n */\nfunction projectStatusOfState(state) {\n    switch (state.status) {\n        case 'loading':\n            return state.extRequest.reload === 0 ? 'loading' : 'reloading';\n        case 'resolved':\n            return isResolved(state.stream()) ? 'resolved' : 'error';\n        default:\n            return state.status;\n    }\n}\nfunction isResolved(state) {\n    return state.error === undefined;\n}\nfunction encapsulateResourceError(error) {\n    if (error instanceof Error) {\n        return error;\n    }\n    return new ResourceWrappedError(error);\n}\nclass ResourceValueError extends Error {\n    constructor(error) {\n        super(ngDevMode\n            ? `Resource is currently in an error state (see Error.cause for details): ${error.message}`\n            : error.message, { cause: error });\n    }\n}\nclass ResourceWrappedError extends Error {\n    constructor(error) {\n        super(ngDevMode\n            ? `Resource returned an error that's not an Error instance: ${String(error)}. Check this error's .cause for the actual error.`\n            : String(error), { cause: error });\n    }\n}\n\nexport { OutputEmitterRef, ResourceImpl, computed, effect, encapsulateResourceError, getOutputDestroyRef, linkedSignal, resource, untracked };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}