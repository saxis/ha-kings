{"ast":null,"code":"/**\n * @license Angular v20.3.0\n * (c) 2010-2025 Google LLC. https://angular.io/\n * License: MIT\n */\n\n/**\n * The default equality function used for `signal` and `computed`, which uses referential equality.\n */\nfunction defaultEquals(a, b) {\n  return Object.is(a, b);\n}\n\n/**\n * The currently active consumer `ReactiveNode`, if running code in a reactive context.\n *\n * Change this via `setActiveConsumer`.\n */\nlet activeConsumer = null;\nlet inNotificationPhase = false;\n/**\n * Global epoch counter. Incremented whenever a source signal is set.\n */\nlet epoch = 1;\n/**\n * If set, called after a producer `ReactiveNode` is created.\n */\nlet postProducerCreatedFn = null;\n/**\n * Symbol used to tell `Signal`s apart from other functions.\n *\n * This can be used to auto-unwrap signals in various cases, or to auto-wrap non-signal values.\n */\nconst SIGNAL = /* @__PURE__ */Symbol('SIGNAL');\nfunction setActiveConsumer(consumer) {\n  const prev = activeConsumer;\n  activeConsumer = consumer;\n  return prev;\n}\nfunction getActiveConsumer() {\n  return activeConsumer;\n}\nfunction isInNotificationPhase() {\n  return inNotificationPhase;\n}\nfunction isReactive(value) {\n  return value[SIGNAL] !== undefined;\n}\nconst REACTIVE_NODE = {\n  version: 0,\n  lastCleanEpoch: 0,\n  dirty: false,\n  producers: undefined,\n  producersTail: undefined,\n  consumers: undefined,\n  consumersTail: undefined,\n  recomputing: false,\n  consumerAllowSignalWrites: false,\n  consumerIsAlwaysLive: false,\n  kind: 'unknown',\n  producerMustRecompute: () => false,\n  producerRecomputeValue: () => {},\n  consumerMarkedDirty: () => {},\n  consumerOnSignalRead: () => {}\n};\n/**\n * Called by implementations when a producer's signal is read.\n */\nfunction producerAccessed(node) {\n  if (inNotificationPhase) {\n    throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode ? `Assertion error: signal read during notification phase` : '');\n  }\n  if (activeConsumer === null) {\n    // Accessed outside of a reactive context, so nothing to record.\n    return;\n  }\n  activeConsumer.consumerOnSignalRead(node);\n  const prevProducerLink = activeConsumer.producersTail;\n  // If the last producer we accessed is the same as the current one, we can skip adding a new\n  // link\n  if (prevProducerLink !== undefined && prevProducerLink.producer === node) {\n    return;\n  }\n  let nextProducerLink = undefined;\n  const isRecomputing = activeConsumer.recomputing;\n  if (isRecomputing) {\n    // If we're incrementally rebuilding the producers list, we want to check if the next producer\n    // in the list is the same as the one we're trying to add.\n    // If the previous producer is defined, then the next producer is just the one that follows it.\n    // Otherwise, we should check the head of the producers list (the first node that we accessed the last time this consumer was run).\n    nextProducerLink = prevProducerLink !== undefined ? prevProducerLink.nextProducer : activeConsumer.producers;\n    if (nextProducerLink !== undefined && nextProducerLink.producer === node) {\n      // If the next producer is the same as the one we're trying to add, we can just update the\n      // last read version, update the tail of the producers list of this rerun, and return.\n      activeConsumer.producersTail = nextProducerLink;\n      nextProducerLink.lastReadVersion = node.version;\n      return;\n    }\n  }\n  const prevConsumerLink = node.consumersTail;\n  // If the producer we're accessing already has a link to this consumer, we can skip adding a new\n  // link. This can short circuit the creation of a new link in the case where the consumer reads alternating ReeactiveNodes\n  if (prevConsumerLink !== undefined && prevConsumerLink.consumer === activeConsumer && (\n  // However, we have to make sure that the link we've discovered isn't from a node that is incrementally rebuilding its producer list\n  !isRecomputing || isValidLink(prevConsumerLink, activeConsumer))) {\n    // If we found an existing link to the consumer we can just return.\n    return;\n  }\n  // If we got here, it means that we need to create a new link between the producer and the consumer.\n  const isLive = consumerIsLive(activeConsumer);\n  const newLink = {\n    producer: node,\n    consumer: activeConsumer,\n    // instead of eagerly destroying the previous link, we delay until we've finished recomputing\n    // the producers list, so that we can destroy all of the old links at once.\n    nextProducer: nextProducerLink,\n    prevConsumer: prevConsumerLink,\n    lastReadVersion: node.version,\n    nextConsumer: undefined\n  };\n  activeConsumer.producersTail = newLink;\n  if (prevProducerLink !== undefined) {\n    prevProducerLink.nextProducer = newLink;\n  } else {\n    activeConsumer.producers = newLink;\n  }\n  if (isLive) {\n    producerAddLiveConsumer(node, newLink);\n  }\n}\n/**\n * Increment the global epoch counter.\n *\n * Called by source producers (that is, not computeds) whenever their values change.\n */\nfunction producerIncrementEpoch() {\n  epoch++;\n}\n/**\n * Ensure this producer's `version` is up-to-date.\n */\nfunction producerUpdateValueVersion(node) {\n  if (consumerIsLive(node) && !node.dirty) {\n    // A live consumer will be marked dirty by producers, so a clean state means that its version\n    // is guaranteed to be up-to-date.\n    return;\n  }\n  if (!node.dirty && node.lastCleanEpoch === epoch) {\n    // Even non-live consumers can skip polling if they previously found themselves to be clean at\n    // the current epoch, since their dependencies could not possibly have changed (such a change\n    // would've increased the epoch).\n    return;\n  }\n  if (!node.producerMustRecompute(node) && !consumerPollProducersForChange(node)) {\n    // None of our producers report a change since the last time they were read, so no\n    // recomputation of our value is necessary, and we can consider ourselves clean.\n    producerMarkClean(node);\n    return;\n  }\n  node.producerRecomputeValue(node);\n  // After recomputing the value, we're no longer dirty.\n  producerMarkClean(node);\n}\n/**\n * Propagate a dirty notification to live consumers of this producer.\n */\nfunction producerNotifyConsumers(node) {\n  if (node.consumers === undefined) {\n    return;\n  }\n  // Prevent signal reads when we're updating the graph\n  const prev = inNotificationPhase;\n  inNotificationPhase = true;\n  try {\n    for (let link = node.consumers; link !== undefined; link = link.nextConsumer) {\n      const consumer = link.consumer;\n      if (!consumer.dirty) {\n        consumerMarkDirty(consumer);\n      }\n    }\n  } finally {\n    inNotificationPhase = prev;\n  }\n}\n/**\n * Whether this `ReactiveNode` in its producer capacity is currently allowed to initiate updates,\n * based on the current consumer context.\n */\nfunction producerUpdatesAllowed() {\n  return activeConsumer?.consumerAllowSignalWrites !== false;\n}\nfunction consumerMarkDirty(node) {\n  node.dirty = true;\n  producerNotifyConsumers(node);\n  node.consumerMarkedDirty?.(node);\n}\nfunction producerMarkClean(node) {\n  node.dirty = false;\n  node.lastCleanEpoch = epoch;\n}\n/**\n * Prepare this consumer to run a computation in its reactive context.\n *\n * Must be called by subclasses which represent reactive computations, before those computations\n * begin.\n */\nfunction consumerBeforeComputation(node) {\n  if (node) {\n    node.producersTail = undefined;\n    node.recomputing = true;\n  }\n  return setActiveConsumer(node);\n}\n/**\n * Finalize this consumer's state after a reactive computation has run.\n *\n * Must be called by subclasses which represent reactive computations, after those computations\n * have finished.\n */\nfunction consumerAfterComputation(node, prevConsumer) {\n  setActiveConsumer(prevConsumer);\n  if (!node) {\n    return;\n  }\n  node.recomputing = false;\n  // We've finished incrementally rebuilding the producers list, now if there are any producers\n  // that are after producersTail, they are stale and should be removed.\n  const producersTail = node.producersTail;\n  let toRemove = producersTail !== undefined ? producersTail.nextProducer : node.producers;\n  if (toRemove !== undefined) {\n    if (consumerIsLive(node)) {\n      // For each stale link, we first unlink it from the producers list of consumers\n      do {\n        toRemove = producerRemoveLiveConsumerLink(toRemove);\n      } while (toRemove !== undefined);\n    }\n    // Now, we can truncate the producers list to remove all stale links.\n    if (producersTail !== undefined) {\n      producersTail.nextProducer = undefined;\n    } else {\n      node.producers = undefined;\n    }\n  }\n}\n/**\n * Determine whether this consumer has any dependencies which have changed since the last time\n * they were read.\n */\nfunction consumerPollProducersForChange(node) {\n  // Poll producers for change.\n  for (let link = node.producers; link !== undefined; link = link.nextProducer) {\n    const producer = link.producer;\n    const seenVersion = link.lastReadVersion;\n    // First check the versions. A mismatch means that the producer's value is known to have\n    // changed since the last time we read it.\n    if (seenVersion !== producer.version) {\n      return true;\n    }\n    // The producer's version is the same as the last time we read it, but it might itself be\n    // stale. Force the producer to recompute its version (calculating a new value if necessary).\n    producerUpdateValueVersion(producer);\n    // Now when we do this check, `producer.version` is guaranteed to be up to date, so if the\n    // versions still match then it has not changed since the last time we read it.\n    if (seenVersion !== producer.version) {\n      return true;\n    }\n  }\n  return false;\n}\n/**\n * Disconnect this consumer from the graph.\n */\nfunction consumerDestroy(node) {\n  if (consumerIsLive(node)) {\n    // Drop all connections from the graph to this node.\n    let link = node.producers;\n    while (link !== undefined) {\n      link = producerRemoveLiveConsumerLink(link);\n    }\n  }\n  // Truncate all the linked lists to drop all connection from this node to the graph.\n  node.producers = undefined;\n  node.producersTail = undefined;\n  node.consumers = undefined;\n  node.consumersTail = undefined;\n}\n/**\n * Add `consumer` as a live consumer of this node.\n *\n * Note that this operation is potentially transitive. If this node becomes live, then it becomes\n * a live consumer of all of its current producers.\n */\nfunction producerAddLiveConsumer(node, link) {\n  const consumersTail = node.consumersTail;\n  const wasLive = consumerIsLive(node);\n  if (consumersTail !== undefined) {\n    link.nextConsumer = consumersTail.nextConsumer;\n    consumersTail.nextConsumer = link;\n  } else {\n    link.nextConsumer = undefined;\n    node.consumers = link;\n  }\n  link.prevConsumer = consumersTail;\n  node.consumersTail = link;\n  if (!wasLive) {\n    for (let link = node.producers; link !== undefined; link = link.nextProducer) {\n      producerAddLiveConsumer(link.producer, link);\n    }\n  }\n}\nfunction producerRemoveLiveConsumerLink(link) {\n  const producer = link.producer;\n  const nextProducer = link.nextProducer;\n  const nextConsumer = link.nextConsumer;\n  const prevConsumer = link.prevConsumer;\n  link.nextConsumer = undefined;\n  link.prevConsumer = undefined;\n  if (nextConsumer !== undefined) {\n    nextConsumer.prevConsumer = prevConsumer;\n  } else {\n    producer.consumersTail = prevConsumer;\n  }\n  if (prevConsumer !== undefined) {\n    prevConsumer.nextConsumer = nextConsumer;\n  } else {\n    producer.consumers = nextConsumer;\n    if (!consumerIsLive(producer)) {\n      let producerLink = producer.producers;\n      while (producerLink !== undefined) {\n        producerLink = producerRemoveLiveConsumerLink(producerLink);\n      }\n    }\n  }\n  return nextProducer;\n}\nfunction consumerIsLive(node) {\n  return node.consumerIsAlwaysLive || node.consumers !== undefined;\n}\nfunction runPostProducerCreatedFn(node) {\n  postProducerCreatedFn?.(node);\n}\nfunction setPostProducerCreatedFn(fn) {\n  const prev = postProducerCreatedFn;\n  postProducerCreatedFn = fn;\n  return prev;\n}\n// While a ReactiveNode is recomputing, it may not have destroyed previous links\n// This allows us to check if a given link will be destroyed by a reactivenode if it were to finish running immediately without accesing any more producers\nfunction isValidLink(checkLink, consumer) {\n  const producersTail = consumer.producersTail;\n  if (producersTail !== undefined) {\n    let link = consumer.producers;\n    do {\n      if (link === checkLink) {\n        return true;\n      }\n      if (link === producersTail) {\n        break;\n      }\n      link = link.nextProducer;\n    } while (link !== undefined);\n  }\n  return false;\n}\n\n/**\n * Create a computed signal which derives a reactive value from an expression.\n */\nfunction createComputed(computation, equal) {\n  const node = Object.create(COMPUTED_NODE);\n  node.computation = computation;\n  if (equal !== undefined) {\n    node.equal = equal;\n  }\n  const computed = () => {\n    // Check if the value needs updating before returning it.\n    producerUpdateValueVersion(node);\n    // Record that someone looked at this signal.\n    producerAccessed(node);\n    if (node.value === ERRORED) {\n      throw node.error;\n    }\n    return node.value;\n  };\n  computed[SIGNAL] = node;\n  if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n    const debugName = node.debugName ? ' (' + node.debugName + ')' : '';\n    computed.toString = () => `[Computed${debugName}: ${node.value}]`;\n  }\n  runPostProducerCreatedFn(node);\n  return computed;\n}\n/**\n * A dedicated symbol used before a computed value has been calculated for the first time.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst UNSET = /* @__PURE__ */Symbol('UNSET');\n/**\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\n * is in progress. Used to detect cycles in computation chains.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst COMPUTING = /* @__PURE__ */Symbol('COMPUTING');\n/**\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\n * failed. The thrown error is cached until the computation gets dirty again.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst ERRORED = /* @__PURE__ */Symbol('ERRORED');\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst COMPUTED_NODE = /* @__PURE__ */(() => {\n  return {\n    ...REACTIVE_NODE,\n    value: UNSET,\n    dirty: true,\n    error: null,\n    equal: defaultEquals,\n    kind: 'computed',\n    producerMustRecompute(node) {\n      // Force a recomputation if there's no current value, or if the current value is in the\n      // process of being calculated (which should throw an error).\n      return node.value === UNSET || node.value === COMPUTING;\n    },\n    producerRecomputeValue(node) {\n      if (node.value === COMPUTING) {\n        // Our computation somehow led to a cyclic read of itself.\n        throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode ? 'Detected cycle in computations.' : '');\n      }\n      const oldValue = node.value;\n      node.value = COMPUTING;\n      const prevConsumer = consumerBeforeComputation(node);\n      let newValue;\n      let wasEqual = false;\n      try {\n        newValue = node.computation();\n        // We want to mark this node as errored if calling `equal` throws; however, we don't want\n        // to track any reactive reads inside `equal`.\n        setActiveConsumer(null);\n        wasEqual = oldValue !== UNSET && oldValue !== ERRORED && newValue !== ERRORED && node.equal(oldValue, newValue);\n      } catch (err) {\n        newValue = ERRORED;\n        node.error = err;\n      } finally {\n        consumerAfterComputation(node, prevConsumer);\n      }\n      if (wasEqual) {\n        // No change to `valueVersion` - old and new values are\n        // semantically equivalent.\n        node.value = oldValue;\n        return;\n      }\n      node.value = newValue;\n      node.version++;\n    }\n  };\n})();\nfunction defaultThrowError() {\n  throw new Error();\n}\nlet throwInvalidWriteToSignalErrorFn = defaultThrowError;\nfunction throwInvalidWriteToSignalError(node) {\n  throwInvalidWriteToSignalErrorFn(node);\n}\nfunction setThrowInvalidWriteToSignalError(fn) {\n  throwInvalidWriteToSignalErrorFn = fn;\n}\n\n/**\n * If set, called after `WritableSignal`s are updated.\n *\n * This hook can be used to achieve various effects, such as running effects synchronously as part\n * of setting a signal.\n */\nlet postSignalSetFn = null;\n/**\n * Creates a `Signal` getter, setter, and updater function.\n */\nfunction createSignal(initialValue, equal) {\n  const node = Object.create(SIGNAL_NODE);\n  node.value = initialValue;\n  if (equal !== undefined) {\n    node.equal = equal;\n  }\n  const getter = () => signalGetFn(node);\n  getter[SIGNAL] = node;\n  if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n    const debugName = node.debugName ? ' (' + node.debugName + ')' : '';\n    getter.toString = () => `[Signal${debugName}: ${node.value}]`;\n  }\n  runPostProducerCreatedFn(node);\n  const set = newValue => signalSetFn(node, newValue);\n  const update = updateFn => signalUpdateFn(node, updateFn);\n  return [getter, set, update];\n}\nfunction setPostSignalSetFn(fn) {\n  const prev = postSignalSetFn;\n  postSignalSetFn = fn;\n  return prev;\n}\nfunction signalGetFn(node) {\n  producerAccessed(node);\n  return node.value;\n}\nfunction signalSetFn(node, newValue) {\n  if (!producerUpdatesAllowed()) {\n    throwInvalidWriteToSignalError(node);\n  }\n  if (!node.equal(node.value, newValue)) {\n    node.value = newValue;\n    signalValueChanged(node);\n  }\n}\nfunction signalUpdateFn(node, updater) {\n  if (!producerUpdatesAllowed()) {\n    throwInvalidWriteToSignalError(node);\n  }\n  signalSetFn(node, updater(node.value));\n}\nfunction runPostSignalSetFn(node) {\n  postSignalSetFn?.(node);\n}\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst SIGNAL_NODE = /* @__PURE__ */(() => {\n  return {\n    ...REACTIVE_NODE,\n    equal: defaultEquals,\n    value: undefined,\n    kind: 'signal'\n  };\n})();\nfunction signalValueChanged(node) {\n  node.version++;\n  producerIncrementEpoch();\n  producerNotifyConsumers(node);\n  postSignalSetFn?.(node);\n}\nexport { COMPUTING, ERRORED, REACTIVE_NODE, SIGNAL, SIGNAL_NODE, UNSET, consumerAfterComputation, consumerBeforeComputation, consumerDestroy, consumerMarkDirty, consumerPollProducersForChange, createComputed, createSignal, defaultEquals, getActiveConsumer, isInNotificationPhase, isReactive, producerAccessed, producerIncrementEpoch, producerMarkClean, producerNotifyConsumers, producerUpdateValueVersion, producerUpdatesAllowed, runPostProducerCreatedFn, runPostSignalSetFn, setActiveConsumer, setPostProducerCreatedFn, setPostSignalSetFn, setThrowInvalidWriteToSignalError, signalGetFn, signalSetFn, signalUpdateFn };","map":{"version":3,"names":["defaultEquals","a","b","Object","is","activeConsumer","inNotificationPhase","epoch","postProducerCreatedFn","SIGNAL","Symbol","setActiveConsumer","consumer","prev","getActiveConsumer","isInNotificationPhase","isReactive","value","undefined","REACTIVE_NODE","version","lastCleanEpoch","dirty","producers","producersTail","consumers","consumersTail","recomputing","consumerAllowSignalWrites","consumerIsAlwaysLive","kind","producerMustRecompute","producerRecomputeValue","consumerMarkedDirty","consumerOnSignalRead","producerAccessed","node","Error","ngDevMode","prevProducerLink","producer","nextProducerLink","isRecomputing","nextProducer","lastReadVersion","prevConsumerLink","isValidLink","isLive","consumerIsLive","newLink","prevConsumer","nextConsumer","producerAddLiveConsumer","producerIncrementEpoch","producerUpdateValueVersion","consumerPollProducersForChange","producerMarkClean","producerNotifyConsumers","link","consumerMarkDirty","producerUpdatesAllowed","consumerBeforeComputation","consumerAfterComputation","toRemove","producerRemoveLiveConsumerLink","seenVersion","consumerDestroy","wasLive","producerLink","runPostProducerCreatedFn","setPostProducerCreatedFn","fn","checkLink","createComputed","computation","equal","create","COMPUTED_NODE","computed","ERRORED","error","debugName","toString","UNSET","COMPUTING","oldValue","newValue","wasEqual","err","defaultThrowError","throwInvalidWriteToSignalErrorFn","throwInvalidWriteToSignalError","setThrowInvalidWriteToSignalError","postSignalSetFn","createSignal","initialValue","SIGNAL_NODE","getter","signalGetFn","set","signalSetFn","update","updateFn","signalUpdateFn","setPostSignalSetFn","signalValueChanged","updater","runPostSignalSetFn"],"sources":["/Users/saxis/dev/angular_projects/ha-kings/node_modules/@angular/core/fesm2022/signal.mjs"],"sourcesContent":["/**\n * @license Angular v20.3.0\n * (c) 2010-2025 Google LLC. https://angular.io/\n * License: MIT\n */\n\n/**\n * The default equality function used for `signal` and `computed`, which uses referential equality.\n */\nfunction defaultEquals(a, b) {\n    return Object.is(a, b);\n}\n\n/**\n * The currently active consumer `ReactiveNode`, if running code in a reactive context.\n *\n * Change this via `setActiveConsumer`.\n */\nlet activeConsumer = null;\nlet inNotificationPhase = false;\n/**\n * Global epoch counter. Incremented whenever a source signal is set.\n */\nlet epoch = 1;\n/**\n * If set, called after a producer `ReactiveNode` is created.\n */\nlet postProducerCreatedFn = null;\n/**\n * Symbol used to tell `Signal`s apart from other functions.\n *\n * This can be used to auto-unwrap signals in various cases, or to auto-wrap non-signal values.\n */\nconst SIGNAL = /* @__PURE__ */ Symbol('SIGNAL');\nfunction setActiveConsumer(consumer) {\n    const prev = activeConsumer;\n    activeConsumer = consumer;\n    return prev;\n}\nfunction getActiveConsumer() {\n    return activeConsumer;\n}\nfunction isInNotificationPhase() {\n    return inNotificationPhase;\n}\nfunction isReactive(value) {\n    return value[SIGNAL] !== undefined;\n}\nconst REACTIVE_NODE = {\n    version: 0,\n    lastCleanEpoch: 0,\n    dirty: false,\n    producers: undefined,\n    producersTail: undefined,\n    consumers: undefined,\n    consumersTail: undefined,\n    recomputing: false,\n    consumerAllowSignalWrites: false,\n    consumerIsAlwaysLive: false,\n    kind: 'unknown',\n    producerMustRecompute: () => false,\n    producerRecomputeValue: () => { },\n    consumerMarkedDirty: () => { },\n    consumerOnSignalRead: () => { },\n};\n/**\n * Called by implementations when a producer's signal is read.\n */\nfunction producerAccessed(node) {\n    if (inNotificationPhase) {\n        throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode\n            ? `Assertion error: signal read during notification phase`\n            : '');\n    }\n    if (activeConsumer === null) {\n        // Accessed outside of a reactive context, so nothing to record.\n        return;\n    }\n    activeConsumer.consumerOnSignalRead(node);\n    const prevProducerLink = activeConsumer.producersTail;\n    // If the last producer we accessed is the same as the current one, we can skip adding a new\n    // link\n    if (prevProducerLink !== undefined && prevProducerLink.producer === node) {\n        return;\n    }\n    let nextProducerLink = undefined;\n    const isRecomputing = activeConsumer.recomputing;\n    if (isRecomputing) {\n        // If we're incrementally rebuilding the producers list, we want to check if the next producer\n        // in the list is the same as the one we're trying to add.\n        // If the previous producer is defined, then the next producer is just the one that follows it.\n        // Otherwise, we should check the head of the producers list (the first node that we accessed the last time this consumer was run).\n        nextProducerLink =\n            prevProducerLink !== undefined ? prevProducerLink.nextProducer : activeConsumer.producers;\n        if (nextProducerLink !== undefined && nextProducerLink.producer === node) {\n            // If the next producer is the same as the one we're trying to add, we can just update the\n            // last read version, update the tail of the producers list of this rerun, and return.\n            activeConsumer.producersTail = nextProducerLink;\n            nextProducerLink.lastReadVersion = node.version;\n            return;\n        }\n    }\n    const prevConsumerLink = node.consumersTail;\n    // If the producer we're accessing already has a link to this consumer, we can skip adding a new\n    // link. This can short circuit the creation of a new link in the case where the consumer reads alternating ReeactiveNodes\n    if (prevConsumerLink !== undefined &&\n        prevConsumerLink.consumer === activeConsumer &&\n        // However, we have to make sure that the link we've discovered isn't from a node that is incrementally rebuilding its producer list\n        (!isRecomputing || isValidLink(prevConsumerLink, activeConsumer))) {\n        // If we found an existing link to the consumer we can just return.\n        return;\n    }\n    // If we got here, it means that we need to create a new link between the producer and the consumer.\n    const isLive = consumerIsLive(activeConsumer);\n    const newLink = {\n        producer: node,\n        consumer: activeConsumer,\n        // instead of eagerly destroying the previous link, we delay until we've finished recomputing\n        // the producers list, so that we can destroy all of the old links at once.\n        nextProducer: nextProducerLink,\n        prevConsumer: prevConsumerLink,\n        lastReadVersion: node.version,\n        nextConsumer: undefined,\n    };\n    activeConsumer.producersTail = newLink;\n    if (prevProducerLink !== undefined) {\n        prevProducerLink.nextProducer = newLink;\n    }\n    else {\n        activeConsumer.producers = newLink;\n    }\n    if (isLive) {\n        producerAddLiveConsumer(node, newLink);\n    }\n}\n/**\n * Increment the global epoch counter.\n *\n * Called by source producers (that is, not computeds) whenever their values change.\n */\nfunction producerIncrementEpoch() {\n    epoch++;\n}\n/**\n * Ensure this producer's `version` is up-to-date.\n */\nfunction producerUpdateValueVersion(node) {\n    if (consumerIsLive(node) && !node.dirty) {\n        // A live consumer will be marked dirty by producers, so a clean state means that its version\n        // is guaranteed to be up-to-date.\n        return;\n    }\n    if (!node.dirty && node.lastCleanEpoch === epoch) {\n        // Even non-live consumers can skip polling if they previously found themselves to be clean at\n        // the current epoch, since their dependencies could not possibly have changed (such a change\n        // would've increased the epoch).\n        return;\n    }\n    if (!node.producerMustRecompute(node) && !consumerPollProducersForChange(node)) {\n        // None of our producers report a change since the last time they were read, so no\n        // recomputation of our value is necessary, and we can consider ourselves clean.\n        producerMarkClean(node);\n        return;\n    }\n    node.producerRecomputeValue(node);\n    // After recomputing the value, we're no longer dirty.\n    producerMarkClean(node);\n}\n/**\n * Propagate a dirty notification to live consumers of this producer.\n */\nfunction producerNotifyConsumers(node) {\n    if (node.consumers === undefined) {\n        return;\n    }\n    // Prevent signal reads when we're updating the graph\n    const prev = inNotificationPhase;\n    inNotificationPhase = true;\n    try {\n        for (let link = node.consumers; link !== undefined; link = link.nextConsumer) {\n            const consumer = link.consumer;\n            if (!consumer.dirty) {\n                consumerMarkDirty(consumer);\n            }\n        }\n    }\n    finally {\n        inNotificationPhase = prev;\n    }\n}\n/**\n * Whether this `ReactiveNode` in its producer capacity is currently allowed to initiate updates,\n * based on the current consumer context.\n */\nfunction producerUpdatesAllowed() {\n    return activeConsumer?.consumerAllowSignalWrites !== false;\n}\nfunction consumerMarkDirty(node) {\n    node.dirty = true;\n    producerNotifyConsumers(node);\n    node.consumerMarkedDirty?.(node);\n}\nfunction producerMarkClean(node) {\n    node.dirty = false;\n    node.lastCleanEpoch = epoch;\n}\n/**\n * Prepare this consumer to run a computation in its reactive context.\n *\n * Must be called by subclasses which represent reactive computations, before those computations\n * begin.\n */\nfunction consumerBeforeComputation(node) {\n    if (node) {\n        node.producersTail = undefined;\n        node.recomputing = true;\n    }\n    return setActiveConsumer(node);\n}\n/**\n * Finalize this consumer's state after a reactive computation has run.\n *\n * Must be called by subclasses which represent reactive computations, after those computations\n * have finished.\n */\nfunction consumerAfterComputation(node, prevConsumer) {\n    setActiveConsumer(prevConsumer);\n    if (!node) {\n        return;\n    }\n    node.recomputing = false;\n    // We've finished incrementally rebuilding the producers list, now if there are any producers\n    // that are after producersTail, they are stale and should be removed.\n    const producersTail = node.producersTail;\n    let toRemove = producersTail !== undefined ? producersTail.nextProducer : node.producers;\n    if (toRemove !== undefined) {\n        if (consumerIsLive(node)) {\n            // For each stale link, we first unlink it from the producers list of consumers\n            do {\n                toRemove = producerRemoveLiveConsumerLink(toRemove);\n            } while (toRemove !== undefined);\n        }\n        // Now, we can truncate the producers list to remove all stale links.\n        if (producersTail !== undefined) {\n            producersTail.nextProducer = undefined;\n        }\n        else {\n            node.producers = undefined;\n        }\n    }\n}\n/**\n * Determine whether this consumer has any dependencies which have changed since the last time\n * they were read.\n */\nfunction consumerPollProducersForChange(node) {\n    // Poll producers for change.\n    for (let link = node.producers; link !== undefined; link = link.nextProducer) {\n        const producer = link.producer;\n        const seenVersion = link.lastReadVersion;\n        // First check the versions. A mismatch means that the producer's value is known to have\n        // changed since the last time we read it.\n        if (seenVersion !== producer.version) {\n            return true;\n        }\n        // The producer's version is the same as the last time we read it, but it might itself be\n        // stale. Force the producer to recompute its version (calculating a new value if necessary).\n        producerUpdateValueVersion(producer);\n        // Now when we do this check, `producer.version` is guaranteed to be up to date, so if the\n        // versions still match then it has not changed since the last time we read it.\n        if (seenVersion !== producer.version) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Disconnect this consumer from the graph.\n */\nfunction consumerDestroy(node) {\n    if (consumerIsLive(node)) {\n        // Drop all connections from the graph to this node.\n        let link = node.producers;\n        while (link !== undefined) {\n            link = producerRemoveLiveConsumerLink(link);\n        }\n    }\n    // Truncate all the linked lists to drop all connection from this node to the graph.\n    node.producers = undefined;\n    node.producersTail = undefined;\n    node.consumers = undefined;\n    node.consumersTail = undefined;\n}\n/**\n * Add `consumer` as a live consumer of this node.\n *\n * Note that this operation is potentially transitive. If this node becomes live, then it becomes\n * a live consumer of all of its current producers.\n */\nfunction producerAddLiveConsumer(node, link) {\n    const consumersTail = node.consumersTail;\n    const wasLive = consumerIsLive(node);\n    if (consumersTail !== undefined) {\n        link.nextConsumer = consumersTail.nextConsumer;\n        consumersTail.nextConsumer = link;\n    }\n    else {\n        link.nextConsumer = undefined;\n        node.consumers = link;\n    }\n    link.prevConsumer = consumersTail;\n    node.consumersTail = link;\n    if (!wasLive) {\n        for (let link = node.producers; link !== undefined; link = link.nextProducer) {\n            producerAddLiveConsumer(link.producer, link);\n        }\n    }\n}\nfunction producerRemoveLiveConsumerLink(link) {\n    const producer = link.producer;\n    const nextProducer = link.nextProducer;\n    const nextConsumer = link.nextConsumer;\n    const prevConsumer = link.prevConsumer;\n    link.nextConsumer = undefined;\n    link.prevConsumer = undefined;\n    if (nextConsumer !== undefined) {\n        nextConsumer.prevConsumer = prevConsumer;\n    }\n    else {\n        producer.consumersTail = prevConsumer;\n    }\n    if (prevConsumer !== undefined) {\n        prevConsumer.nextConsumer = nextConsumer;\n    }\n    else {\n        producer.consumers = nextConsumer;\n        if (!consumerIsLive(producer)) {\n            let producerLink = producer.producers;\n            while (producerLink !== undefined) {\n                producerLink = producerRemoveLiveConsumerLink(producerLink);\n            }\n        }\n    }\n    return nextProducer;\n}\nfunction consumerIsLive(node) {\n    return node.consumerIsAlwaysLive || node.consumers !== undefined;\n}\nfunction runPostProducerCreatedFn(node) {\n    postProducerCreatedFn?.(node);\n}\nfunction setPostProducerCreatedFn(fn) {\n    const prev = postProducerCreatedFn;\n    postProducerCreatedFn = fn;\n    return prev;\n}\n// While a ReactiveNode is recomputing, it may not have destroyed previous links\n// This allows us to check if a given link will be destroyed by a reactivenode if it were to finish running immediately without accesing any more producers\nfunction isValidLink(checkLink, consumer) {\n    const producersTail = consumer.producersTail;\n    if (producersTail !== undefined) {\n        let link = consumer.producers;\n        do {\n            if (link === checkLink) {\n                return true;\n            }\n            if (link === producersTail) {\n                break;\n            }\n            link = link.nextProducer;\n        } while (link !== undefined);\n    }\n    return false;\n}\n\n/**\n * Create a computed signal which derives a reactive value from an expression.\n */\nfunction createComputed(computation, equal) {\n    const node = Object.create(COMPUTED_NODE);\n    node.computation = computation;\n    if (equal !== undefined) {\n        node.equal = equal;\n    }\n    const computed = () => {\n        // Check if the value needs updating before returning it.\n        producerUpdateValueVersion(node);\n        // Record that someone looked at this signal.\n        producerAccessed(node);\n        if (node.value === ERRORED) {\n            throw node.error;\n        }\n        return node.value;\n    };\n    computed[SIGNAL] = node;\n    if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n        const debugName = node.debugName ? ' (' + node.debugName + ')' : '';\n        computed.toString = () => `[Computed${debugName}: ${node.value}]`;\n    }\n    runPostProducerCreatedFn(node);\n    return computed;\n}\n/**\n * A dedicated symbol used before a computed value has been calculated for the first time.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst UNSET = /* @__PURE__ */ Symbol('UNSET');\n/**\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\n * is in progress. Used to detect cycles in computation chains.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst COMPUTING = /* @__PURE__ */ Symbol('COMPUTING');\n/**\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\n * failed. The thrown error is cached until the computation gets dirty again.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst ERRORED = /* @__PURE__ */ Symbol('ERRORED');\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst COMPUTED_NODE = /* @__PURE__ */ (() => {\n    return {\n        ...REACTIVE_NODE,\n        value: UNSET,\n        dirty: true,\n        error: null,\n        equal: defaultEquals,\n        kind: 'computed',\n        producerMustRecompute(node) {\n            // Force a recomputation if there's no current value, or if the current value is in the\n            // process of being calculated (which should throw an error).\n            return node.value === UNSET || node.value === COMPUTING;\n        },\n        producerRecomputeValue(node) {\n            if (node.value === COMPUTING) {\n                // Our computation somehow led to a cyclic read of itself.\n                throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode ? 'Detected cycle in computations.' : '');\n            }\n            const oldValue = node.value;\n            node.value = COMPUTING;\n            const prevConsumer = consumerBeforeComputation(node);\n            let newValue;\n            let wasEqual = false;\n            try {\n                newValue = node.computation();\n                // We want to mark this node as errored if calling `equal` throws; however, we don't want\n                // to track any reactive reads inside `equal`.\n                setActiveConsumer(null);\n                wasEqual =\n                    oldValue !== UNSET &&\n                        oldValue !== ERRORED &&\n                        newValue !== ERRORED &&\n                        node.equal(oldValue, newValue);\n            }\n            catch (err) {\n                newValue = ERRORED;\n                node.error = err;\n            }\n            finally {\n                consumerAfterComputation(node, prevConsumer);\n            }\n            if (wasEqual) {\n                // No change to `valueVersion` - old and new values are\n                // semantically equivalent.\n                node.value = oldValue;\n                return;\n            }\n            node.value = newValue;\n            node.version++;\n        },\n    };\n})();\n\nfunction defaultThrowError() {\n    throw new Error();\n}\nlet throwInvalidWriteToSignalErrorFn = defaultThrowError;\nfunction throwInvalidWriteToSignalError(node) {\n    throwInvalidWriteToSignalErrorFn(node);\n}\nfunction setThrowInvalidWriteToSignalError(fn) {\n    throwInvalidWriteToSignalErrorFn = fn;\n}\n\n/**\n * If set, called after `WritableSignal`s are updated.\n *\n * This hook can be used to achieve various effects, such as running effects synchronously as part\n * of setting a signal.\n */\nlet postSignalSetFn = null;\n/**\n * Creates a `Signal` getter, setter, and updater function.\n */\nfunction createSignal(initialValue, equal) {\n    const node = Object.create(SIGNAL_NODE);\n    node.value = initialValue;\n    if (equal !== undefined) {\n        node.equal = equal;\n    }\n    const getter = (() => signalGetFn(node));\n    getter[SIGNAL] = node;\n    if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n        const debugName = node.debugName ? ' (' + node.debugName + ')' : '';\n        getter.toString = () => `[Signal${debugName}: ${node.value}]`;\n    }\n    runPostProducerCreatedFn(node);\n    const set = (newValue) => signalSetFn(node, newValue);\n    const update = (updateFn) => signalUpdateFn(node, updateFn);\n    return [getter, set, update];\n}\nfunction setPostSignalSetFn(fn) {\n    const prev = postSignalSetFn;\n    postSignalSetFn = fn;\n    return prev;\n}\nfunction signalGetFn(node) {\n    producerAccessed(node);\n    return node.value;\n}\nfunction signalSetFn(node, newValue) {\n    if (!producerUpdatesAllowed()) {\n        throwInvalidWriteToSignalError(node);\n    }\n    if (!node.equal(node.value, newValue)) {\n        node.value = newValue;\n        signalValueChanged(node);\n    }\n}\nfunction signalUpdateFn(node, updater) {\n    if (!producerUpdatesAllowed()) {\n        throwInvalidWriteToSignalError(node);\n    }\n    signalSetFn(node, updater(node.value));\n}\nfunction runPostSignalSetFn(node) {\n    postSignalSetFn?.(node);\n}\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst SIGNAL_NODE = /* @__PURE__ */ (() => {\n    return {\n        ...REACTIVE_NODE,\n        equal: defaultEquals,\n        value: undefined,\n        kind: 'signal',\n    };\n})();\nfunction signalValueChanged(node) {\n    node.version++;\n    producerIncrementEpoch();\n    producerNotifyConsumers(node);\n    postSignalSetFn?.(node);\n}\n\nexport { COMPUTING, ERRORED, REACTIVE_NODE, SIGNAL, SIGNAL_NODE, UNSET, consumerAfterComputation, consumerBeforeComputation, consumerDestroy, consumerMarkDirty, consumerPollProducersForChange, createComputed, createSignal, defaultEquals, getActiveConsumer, isInNotificationPhase, isReactive, producerAccessed, producerIncrementEpoch, producerMarkClean, producerNotifyConsumers, producerUpdateValueVersion, producerUpdatesAllowed, runPostProducerCreatedFn, runPostSignalSetFn, setActiveConsumer, setPostProducerCreatedFn, setPostSignalSetFn, setThrowInvalidWriteToSignalError, signalGetFn, signalSetFn, signalUpdateFn };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}